# 効果的なトラブルシューティング

- トラブルに対応する力は、大事だけど天性のものに見られがち
    - 習慣的なものでどうやってやるかを説明するのが難しい

- 訓練は以下の2つが大事
  - 一般的にどうやってトラブルに対応するか
  - システムに対する理解
  - 一般的な手順とかに頼ってやるのは、システムがどうやって動作するかを理解して行うよりも劣る

## Theory

- トラブルシューティングのプロセスは仮説演繹法の応用
    - 観察、理解 => 仮説 => 仮説の検証

- 図12-1の例
    - アラートなどをきっかけに、logなどを手がかりに現状を理解する
    - 現状と、システムがどのように構成されてるか、どのように操作すべきか、障害の種類などから原因を特定する

- 仮説を検証する方法には2つある
    1. 観察されたシステムの状態と理論を比較して証拠を見つける
    2. システムに変化を与えて結果を観察する
- このどちらかを使って、根本原因が特定できるまで検証を繰り返す
    - 原因が特定できたら、再発防止策を講じるか、検討を行う

## コラム：一般的な落とし穴

- 避けるべき落とし穴4選
    1. 無関係の症状を注視すること、メトリクスの意味を誤解すること => 無駄な努力
    2. システム、入力、環境の変更の方法を誤解すること
    3. 何が誤っているのかについて予想だにしない理屈を思いつくこと
        - 過去の問題に固執するあまり、一度起きたことを理由にもう一度起こるとか言い出したりすること
    4. 誤った相関関係を一生懸命に突き止めること
        - 実際には偶然の一致であったり、共通の原因によるものだったりする
- 1と2を修正することは、当該のシステムについて学ぶことや分散システムにおいて共通のパターンについて習熟することが大事
- 3については、すべての障害が同様に起こるわけではないことを心に留めておく
    - `when you hear hoofbeats(蹄の音), think of hourses not zebras.`
    - 同様にすべての物事は等しいことも忘れてはいけない
- 4については、相関自体は原因でないことを心に留めておく
    - 例えば、停電が原因の場合の同一クラスタ内のパケロスとディスク故障
    - システムが大きく複雑になって、メトリクスの数が多くなってくると他のイベントに関連して偶然に発生するイベントは避けられない

## In Practice

- トラブルシューティングのプロセスを辛くなくて生産的にすることができるステップがある（らしい。ほう。）
    - 基本的に図12-1の流れにそって説明がすすんでいくjo

### Problem Report

- 問題はここから始まる（アラートだったり、同僚が「システム遅い！」って言ったりすることだったり）
- 効果的なreportに含まれるべきもの
    - 期待される振る舞い
    - 実際の振る舞い
    - どうすればその振る舞いを抑えられるか（アラートに対して具体的なアクションが書いてあるとか？）
    - 参考文献：http://www.chiark.greenend.org.uk/~sgtatham/bugs-jp.html
- reportは一貫した形式を持つべきで、バグトラッキングシステムみたいな検索可能な場所にあるべき
    - Googleでは、小さいwebアプリがあってフォームに情報を入れると特定のシステムに関して自動的にバグを突き止めることができるらしい
- 一番はじめのこのstepで自分で原因を特定したり、自己修復できるツールを入れるのはいいかもしれない

- Googleでは発生したすべての問題に対してbug issueを開くようにしてる
    - 参照しやすい調査・改善ログが自動的にできる
    - 人間に直接報告するよりもいい
        - 受けた報告をbug issueにする手間が発生する
        - 他のチームメンバーに見えない場合もある
        - 問題解決の負担がたまたま問題を知った一部のメンバーに集中しがちになる

### Triage（優先順位付け）

- Probem reportを受け取ったら、それに対してどう対処するかを明確にするのが次のステップ
- 問題は深刻度に違いがある
    - 特定の環境で特定のユーザだけが影響を受けるもの
    - サービス全体が影響を受けるもの
- 対応は問題の影響に対して適切な程度であるべき
    - 例えば、上の例の後者に対して総力を上げるのは適切だけど、前者に対してはやり過ぎ
- 問題の深刻さの評価に必要なもの
    - 技術的な判断の訓練
    - プレッシャー下での心の平静

- 障害が発生した時に、トラブルシューティングを始めたり、原因を探し始めたりしがちだけど、我慢しないといけない。
- 一番はじめにすべきなのは、とりあえず動くようにすること（一次対応っていう理解でいいのかな）
    - 緊急時のオプションを取る
        - 例えば、
        - 故障したクラスタから他のクラスタへトラフィックを迂回させる
        - 障害の伝搬を防ぐためにトラフィックを遮断する
        - 負荷を軽減するためにサブシステムを落とす
- 例えていうと、怪我をしたときに出血を止めることが再優先
    - 原因探しをしている間にシステムが死んだら意味が無い
- 素早く優先順位をつけることで、原因究明のための証拠（logとか）の保存が不可能になるわけではない

- パイロットの話
    - 新入りは「トラブルの際の最優先事項は飛行機を飛ばすことだ」と教えられるらしい
    - トラブルシューティングはその次
- システムにおいても同じ
    - 例えば、
    - データロストを引き起こすバグがあったとして、それを動かし続けて原因を探すよりは、殺してしまったほうが良い（まあ当然っぽいけど、パニックになっても同じ判断ができることが大事そう）

### Examine（調査）

- 正常かどうかを判断するためには、システムの構成要素が何をしているかを調べることができないとならない

- 10章みたいにメトリクスが保存されてるのが理想
    - メトリクスから調査をはじめるのは良い

- ログはめっちゃいい道具
    - いつ、なにが起きたのかを正確に理解できる
    - システムのログを解析したり、ツールスタック全体のログを見たり
    - GoogleではDapperっていうの使ってるらしい
        - http://research.google.com/pubs/pub36356.html

- Googleの例
    - サーバに最近やり取りしたRPCのサンプルを返すエンドポイントがはえてる
        - アーキテクチャ図を見なくても、どことどんなやり取りをしたかが分かる
    - エラーレートのヒストグラムとか、RPCのタイプごとにレイテンシを出すエンドポイントもある
    - 今の設定ファイルやデータを吐き出すエンドポイント持ってるやつもいる

- クライアントの方にも施策が必要な場合もある
    - リクエストとレスポンスを見たりみたいな場合

### コラム：Logging

- テキストログはリアルタイムでデバッグをするのに向いてる
    - 対して構造化されたバイナリログは、より詳細に分析するツールを作るのを可能にする

- ログにも複数のレベルの冗長度を持たせたら便利
- ログが多すぎる場合にはサンプリングすればいい

- より発展すると
    - 「この操作にマッチするログを出して」というようなことを可能にする言語とかログ基盤

### Diagnose

### Test and Treat

## Negative Results Are Magic

### Cure

## Case Study

## Making Troubleshooting Easiser

## Conclusion
