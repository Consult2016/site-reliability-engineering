7 The Evolution of Automation at Google
==============================

- 自動化(`automation`)は万能薬ではなく、力の乗算機
- 力の乗算機はそれがない場合と同じ結果になる必要がある
  - 自動化はよく考えて行う必要がある。そうしないと自動化が解決する問題よりも多くの問題が発生する
- ソフトウェアによる自動化はほとんどの場合手動操作よりも優れている。どちらよりも更に優れているのは自律動作するシステムのような、高度な設計
- この章では自動化の価値と時間による自分たちの態度の変遷について記載

## The Value of Automation(自動化の価値)

### Consistency(一貫性)

- 自動化の明白な動機はスケールすることだが、それ以外にもたくさんの理由がある
- 大学のコンピューティングシステムではユーザアカウント作成やDNSの設定変更などを、手で実施しているが、組織や本人にとって満足のいくものではなかった
- 同じ操作を何度もされるが、一貫した方法では実施されない
- 一貫性の欠如は、見落とし、データ品質の問題、ミス、信頼性の問題に繋がる
- well-scopedな知られた手続きの実行という意味での自動化において、一貫性は自動化の第一の価値である

### A Platform

- 設計されてうまく動く自動化システムは拡張可能でたくさんのシステムに適用できるプラットフォームを提供する。利益のためにスピンアウトすることさえある(spin outとは？製品として売りだすとかそういうこと？それとも、廃止すること？)
- 自動化されたシステムは、既に動いているプロセスを深く理解することを可能にするという点で、それ自体で価値がある
- 自動化されていないシステムはコスト的に悪く、また拡張可能でもない。これは、システムの運用に対して税として課される
- プラットフォームはミスを一元化する
- 自動化されておらず人間が実行している場合と異なり、一度コードが修正されれば二度と起きなくなる
- タスクを追加するのも人間にタスク追加を指示するよりも簡単
- 人間が実行する場合と比べて、タスクの性質に応じてより何度も実行したり常に実行させたりが可能になる
- プラットフォームはタスクのメトリクスを出力することができる。プラットフォームという文脈では、タスクの計測が楽になるので、タスクの詳細を知ることができるようになる

### Faster Repairs

- 自動化が適切に動けば一般的なシステムの問題に対してのMTTR(mean time to repair)を下げることができる
- MTTRの減少により、問題を防いだりクリーンアップしたりすることに時間を使う必要がなくなり、それによって他のタスクに時間を費やしてベロシティを上げることができる
- 問題の発見がプロダクト・ライフサイクルの後になればなるほど修正コストが高くなるので、動いた瞬間に問題を発見するようなシステムはコストを下げるのに役立つ

### Faster Action

- 人間は一般的に機械ほど素早く反応できない
- 例えば、fail overシステムにおいて、人間が"fail overを続けます"ボタンを押す必要はない
  - もちろん自動化が時として事態をより悪くする場合もあるが、それは自動化された手続きが、よく定義されたドメイン上にスコープされるべき理由である

### Time Saving

- 時間の節約は、自動化の利点としてよくあげられるが、そんなに明確な話ではない
- エンジニアは自動化にかかるコストとそれを手で行うコストの比較をして、自動化を行うかどうかを迷う
- 一度、いくつかのタスクをカプセル化して自動化すると、他の人はだれでも実行できるようになるというのを見過ごしがちであり、時間の節約はそれを使い得る全ての人に適用される
- 自動化されないと、手作業のために人を雇い、人類の血と汗と涙で機械を管理する必要がある

## The Value for Google SRE(Google SREの価値)

- 上記の利点やトレードオフはGoogleにも適用され、Googleは自動化に向けた非常に強いバイアスを持っている
- Googleは世界規模のサービスを提供しており極めて巨大なので、手作業をしている余裕はない
- 一貫性と素早さと信頼性は自動化のトレードオフについての会話を支配している(それらのためにはトレードオフはそんなに問題にならないということだろう)
- Googleにおいて、自動化を支持するもう一つの要因は、第2章で説明した、複雑だが驚くほど均一なプロダクション環境
- Googleはアクセス可能なAPIを持っていなかったり内部のソースコードが存在しなかったりその他プロダクションのオペレーションで完全に制御することを拒むような製品を避ける
- ベンダからAPIを提供されない場合は自分でAPIを構築する
- 特定のタスクのための製品を購入することは短期的には安く済むが、長期的なコスト削減のためのAPIを構築するため、自分たちでソリューションを作り上げることを選択する
- Googleは自動システム管理の自動化のための障害を取り除くことに多くの時間を費やし、またシステム自身が自分を管理するような自動システムを開発してきた
- Googleがそのソースコードをどのように管理しているか(The Motivation for a Monolithic Codebase:)については、SREがさわるシステムのソースコードへ触れることは、また、"own the product in production(プロダクション環境の中のプロダクトを保持する？？？)"へのSREのミッションが、全てのスタックをコントロールできるという理由で圧倒的に簡単だということを意味している
- 現実的には、全てをシステム自身で自動管理できるわけではない
- 全てのコンポーネントを自律管理できるわけではないし、人によって自動化をすすめる能力などの違いがある
- 重要なシステムの中には持続する設計になっていなかったり自動化のためのインターフェースの存在しない迅速なプロトタイプとしてスタートしたものもある(大変そうですね)
- 前の章(アクセス可能なAPIをもってないものを避ける等)では自分たちのポジションに対する過激な発言をしましたが、one that we have been broadly successful at putting into action within the Google context.
- 一般的には、私たちはplatformを作ることを選んだ。もしくは、自分たち自身をplatformを作れるようなポジションにおいているので、我々はplatformを作れるようになってきた
- 私たちは、このplatformベースのアプローチを管理のしやすさとスケーラビリティのために必要だと感じている

## The Use Cases for Automation

- 業界では、一般的に自動化という用語は様々な問題を解くためにコードを書くこととなっている
  - そのコードを書くモチベーションや解決策それ自体は全くちがうものなのに
- ここでは、自動化をより広く捉え、自動化をメタソフトウェア(ソフトウェアに従うソフトウェア)として扱う
- 自動化のユースケースの非網羅的リストは以下のとおり
  - ユーザアカウント作成
  - サービスに対するクラスタの投入/外し
  - ソフトウェアやハードウェアのインストール準備/廃止
  - 新しいソフトウェアのデプロイ
  - 設定の変更
  - 特別な設定の変更: 依存の変更

このリストは無限に続く

### Google SRE's Use Cases for Automation

- SREの主な親和性はインフラの上を通るデータの質を管理することではなく、インフラを動かすことにある。
- この行は完全に明確ではない。例えば、私たちは、デプロイによってデータの半分が消失することを非常に気にかけているので、粗い違いについて気にかけているが、細かいデータの変更の同等性について書くことはほとんどない
- 従って、自動化はしばしばシステムのライフサイクルの管理であり、データの管理ではないというコンテキスト。例えば、新しいクラスタへのデプロイ。
- この範囲で、SREの自動化努力は他の人や組織がしていることと、別の焦点を持ち別のツールを使う(後で議論する)ことを除けばそんなに離れていない
- Puppet, Chef, cfengine, そしてPerlのような、特定のタスクの自動化の方法を提供する、広く利用可能なツールは、自動化の行為を助けるために提供されるコンポーネントの抽象化のレベルの点で主に異なります。
- Perlのような言語は理論的にシステムにアクセスするAPI全体で自動化の無制限の範囲を提供するPOSIXレベルのアフォーダンスを提供する一方でChefやPuppetはサービスの、より高いレベルでの画期的な抽象化を提供する
- 上記のトレードオフは古典的。より高いレベルの抽象化は管理し、理解するのは簡単だが抽象化の漏れがあった際にシステム的に、繰り返し、失敗し、潜在的に一貫しない状態となる
- 例えば、我々は新しいバイナリをクラスタにpushすることはアトミックである(最終的に古いバージョン化新しいバージョンのどちらかとなる)ことを前提としている
- しかし、我々の世界はもっと複雑であり、クラスタのネットワークが片道だけ失敗しうるし機械は失敗しうるしクラスタ管理システムとの疎通が切れえるなどで、システムが一貫性のない状態となることがある
- 状況に応じて新しいバイナリはstageに乗るがpushされていなかったりpushされてもrestartしなかったりrestartしても確認できなかったりし、ほとんどの場合は最終的に停止して介入を要請する。本当に最悪な自動化は、介入の要請すらしない
- SREはたくさんの自動化についての哲学及び製品を持っている
- 特定の詳細なモデルのない一般的なデプロイツールもあれば非常に抽象的なレベルでサービスを記述する言語もある
  - 後者は前者よりも再利用しやすくより共通のプラットフォームとなる。しかしGoogleの本番環境の複雑さは、前者のアプローチの方が最も扱いやすい選択肢となる

### A Hierarchy of Automation Classes

この節の前半部分、全体的に全然意味がわからなかった

- それらの自動化のステップは価値があり、自動化のプラットフォームもそれ自身価値があるが、理想の世界では外部化された自動化は必要ない
- 実際、外部のグルー・ロジックをもつ必要があるシステムの代わりにグルーロジックを全く持たないシステムのほうが良い
- それは内部化がより効果的だからというだけではなく、グルーロジックを最初の場所で必要のないようにデザインされているからである
- それの達成は、グルーロジックのためのユースケースを取得(一般的に、アカウントの追加やシステムのリリース(: turnup)のようなシステムの最初の命令操作)すること及びそれらのユースケースをアプリケーションの中で直接扱う方法を見つけることと関連する
- より詳細な例を出すと、ほとんどのturnup自動化は問題をはらんでいる。なぜならそれらはコアシステムとは分離して保持され、従ってbit rotに苦しめられる。換言すれば、下にあるシステムの変更があっても変更されずにいるなど。
- 最高の注意にもかかわらず、リリースの自動化とコアシステムをより強くつなごうとする試みは優先度が直列化されていないためしばしば失敗する。なぜなら、開発者は全変更の際にテストデプロイを行うことに抵抗するからである
- 第二に、極めて重要だが稀にしか実行されずテストが難しい自動化は少ないフィードバックサイクルによりしばしば特に壊れやすい
- クラスタのフェイルオーバはあまり実施されない自動化の典型的な例です
- 自動化の進展は以下のパスをたどる
  - 自動化なし
    - DBのmasterのフェイルオーバは手で実施される
  - システム固有の、外部管理されている自動化
    - SREは自分のホームディレクトリ内にフェイルオーバスクリプトがあります
  - 一般的な、外部管理されている自動化
    - 皆が使っている一般的なフェイルオーバスクリプトにDBのサポートを追加する
  - システム特有の、内部管理されている自動化
    - DBは自分自身のフェイルオーバスクリプトと共に動く
  - 自動化が不要なシステム
    - DBが自分で問題に気付き、人間の介在なしで自動でフェイルオーバする
- SREは手動のオペレーションを嫌うので、手動のオペレーションが不要なシステムを構築しようとする。しかし、しばしば手動のオペレーションは避けられない
- 加えて、特定のシステムに関連した設定ファイルの領域を通してではなく、製品全体の領域を通しての変更の適用という、自動化の亜種がある
- Googleのような高度に中央集権された環境では、サービス特有ではない変更が大量に行われている
- 例えば、Chubbyのupstreamサーバの変更、BigTable Clientがより信頼性の高いデータアクセスを行うためのフラグの変更、等など
- それらは安全に管理され、必要であればロールバックされる
- 変更量が一定を越えると手動での適用は不可能となる。そしてしばしばそのポイントの前に変更の大部分は自明か基本的なデプロイしては確認する戦略で成功している場合のプロセスのための手動の漏れは無駄である
- それでは、先行するいくつかのポイントを詳細に説明するために、内部ケーススタディを使用してみましょう。
- 最初のケーススタディは、どのように、幾つかの真面目で遠慮のある仕事によって、SREの自称の涅槃(ジョブの外の彼ら自身を自動化する)への到達を管理するかである

## Automate Yourself Out of a Job: Automate ALL the Things!



